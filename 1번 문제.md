
## 동시에 같은 DB Table row 를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하실 건지 설명해주세요.

### Locking(잠금) 기법
Locking은 하나의 트랜잭션이 실행하는 동안 특정 데이터 항목에 대해서 다른 트랜잭션이 동시에 접근하지 못하도록 상호배제(mutual exclusive)를 제공하는 기법이다. 하나의 트랜잭션이 데이터 항목에 대하여 Lock을 설정하면, 잠금을 설정한 트랜잭션이 해제할 때까지 데이터를 독점적으로 사용할 수 있다.

한번에 로킹 할 수 있는 데이터 크기를 로킹 단위라고 하며 필드, 레코드, 테이블, 파일, 데이터베이스 모두 로킹 단위가 될 수 있다.

### Locking에 사용되는 연산
잠금 기법은 기본적으로 lock 연산과 unlock 연산을 사용한다.

### 잠금 연산의 종류
잠금 연산은 데이터에 대한 연산의 성격에 따라 공유잠금(shared lock:s-lock)과 배타잠금(exclusive lock : x-lock)으로 나눌 수 있다. 모든 트랜잭션은 데이터 항목에 대한 접근을 시도할 때 둘 중 하나의 잠금 방법을 사용한다. 공유잠금과 배타잠금 모두 잠금을 해제할 경우에는 unlock 연산을 이용한다.

배타잠금은 write에 대한 lock
update,delete 등의 수정 쿼리를 날릴 때 각 row에 걸리는 lock
x-lock이 걸려 있으면 다른 트랜잭션은 s-lock, x-lock 둘다 걸 수 없다.

공유잠금은 read에 대한 lock
일반적인 select 쿼리가 아닌 select ... lock in share mode 또는 select ... for share(8.0 버전부터)를 사용해 read 작업을 수행할 때 사용
s-lock이 걸려 있는 row에 다른 트랜잭션이 s-lock을 걸 수 있으나 x-lock은 걸 수 없다.

### Locking 규약
1. 트랜잭션 T가 공유데이터 x에 접근하려면 먼저 lock(x)를 해야한다.
2. 공유 데이터를 사용한 트랜잭션 T는 반드시 unlock(x)를 해야한다.
3. 다른 트랜잭션에 의해 lock(x)가 실행되었다면 트랜잭션 T는 lock(x)를 실행하지 못한다.
4. 트랜잭션 T가 lock(x)한 것을 다른 트랜잭션이 unlock(x)할 수 없다.

하나의 트랜잭션만이 공유 데이터를 사용할 수 있는데, 실제로 오직 읽기(read)만 하는 경우에는 동시에 접근해도 문제가 없기 때문에 이런 경우에 효율적이지 못하다.
따라서 위와 같은 문제점을 해결하기 위해 사용되는 것이 2단계 로킹 규약이다. 

Locking 기법은 교착 상태가 발생할 수 있다는 한계가 있다.
교착 상태란, 여러 트랜잭션이 특정 데이터에 lock을 한 채 다른 트랜잭션이 lock을 수행한 데이터에 접근하려고 할 때 실행을 하지 못하고 서로 무한정 기다리는 상태를 말한다. -> 문제와 같은 상황

교착상태를 개선하기 위해
### 교착상태 감지
   - 교착상태 감지 및 timeout
     일정 시간 이후 트랜잭션이 실행되지 않았을 경우 롤백
### 교착상태 방지
  - 격리수준 변경
    교착 상태를 방지하기 위해 격리수준을 행수준 잠금 또는 격리 수준을 조정
  - 서비스 로직을 교차 되지 않게 수정
  - wait-die 또는 wount wait 방법
    타임스탬프를 기반으로 트랜잭션을 대기,선점,종료하는 방식
### 2단계 locking 규악
2단계 locking 규약은 각 트랜잭션의 lock과 unlock 요청을 2단계로 실시하는 방식이다.
단계는 확장 단계와 축소 단계로 나뉜다.
- 확장 단계 : 새로운 lock 연산만을 수행할 수 있고, unlock 연산은 수행할 수 없는 단계이다.
- 축소 단계 : unlock 연산을 수행할 수 있고, lock 연산은 수행할 수 없는 단계이다.
2단계 로킹 규약은 트랜잭션 내의 모든 lock 연산이 첫번째 unlock연산 이전에 위치해야 한다. 따라서 하나의 트랜잭션에서 데이터에 대한 연산을 완전히 끝낸 후 unlock 하므로 직렬성이 보장된다.

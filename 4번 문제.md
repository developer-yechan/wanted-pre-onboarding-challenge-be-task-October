# Javascript 설계적 결함

## 높은 자유도
숫자와 boolean을 더해도 오류가 나지 않는다. 대부분의 다른 언어는 오류를 내지만 자바스크립트는 true를 2진수로 변환해 계산한다. 예를들어 1 + true = 2가 된다.

function multiply(a,b) { 
return a*b
};

이런 함수가 있을 때 함수 선언 시 a,b 두개의 매개변수를 설정했음에도
매개변수 없이 
multiply();
이렇게 호출하거나
multiply(true,"hi) 이런 식으로 숫자 타입이 아닌 매개변수를 넣어도 오류가 발생하지 않는다.

이러한 문제를 해결하기 위해 Typescript가 등장했다. 매개 변수의 type을 미리 설정해서 다른 type의 매개변수가 입력 됐을 경우 에러를 반환한다.

그래서 개발자가 위와 같은 실수를 했을 때 런타임 오류가 뜨지 않도록 사전에 방지해준다. 

ES6 const,let 문법이 나오기 전 모든 변수를 var로 선언했을 때에도 var hoisting 때문에
변수를 식별자에 대입해주기 전에 식별자를 호출해서 사용해도 에러가 발생하지 않았다.
const,let 문법이 나온 이후로는 식별자에 변수가 대입되기 전에 식별자가 호출 되면 temporal dead zone(tdz) 오류가 발생하여 실제로 변수가 선언되고 값이 할당된 라인 전까지는 해당 식별자에 일시적으로 접근할 수 없게 하여 개발자의 실수로 인한 런타임 오류가 발생하지 않게 했다.
